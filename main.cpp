#include <iostream>
#include <fstream>
#include <sstream>
#include <cstdlib>
#include <cstdio>
#include <omp.h>
#include <string>
#include <cmath>
#include <vector>
#include <numeric>

using namespace std;

void printarray(vector<int>& a, int n);
void gensubstrarr(vector<int>& a, string substr);
int kmp_findsubstr(vector<int>& a, string str, string substr, bool withPrint);
int kmp_findsubstr_par(vector<int>& a, string str, string substr, bool withPrint);
string run_simulation(vector<int>& a, string str, string substr, int N);
string repeat_str(int N, string str);

const string FILENAME_BOOK1("./data/calgary/book1"); // 16622 lines
const string FILENAME_NEWS("./data/calgary/news"); // ~Â 10000 lines

const string FILENAME_PAPER1("./data/calgary/paper1"); // 1250 lines
const string FILENAME_PAPER4("./data/calgary/paper4"); // 294 lines

string readFileIntoString(const string& path) {
    ifstream input_file(path);
    if (!input_file.is_open()) {
        cerr << "Could not open the file - '"
             << path << "'" << endl;
        exit(EXIT_FAILURE);
    }
    return string((std::istreambuf_iterator<char>(input_file)), std::istreambuf_iterator<char>());
}

int main(int argc, char **argv){
    string substr;
    // Take substring from argument if it's given, otherwise read file
    if (argc > 1) {
      substr = argv[1];
    } else {
      printf("Taking substr from file\n");
      substr = readFileIntoString(FILENAME_PAPER4);
      substr = substr;
      substr = repeat_str(3, substr);
      printf("Read!\n");
    }
    int m = substr.length();

    vector<int> a;
    a.reserve(m);
    gensubstrarr(a, substr);

    printf("\nStarting substr search\n");
    printf("Substr string length: %d\n\n", m);
    string testString = readFileIntoString(FILENAME_BOOK1);

    // Run simulation and write results to file
    ofstream resultsFile("results_long.txt");
    for (int i = 1; i < 300; i += 10) {
      string str = repeat_str(i, testString);
      printf("RUNNING SIMULATION %d\n", i);
      string result = run_simulation(a, str, substr, 10);
      resultsFile << result + "\n";
    }
    for (int i = 300; i < 1000; i += 20) {
      printf("RUNNING SIMULATION %d\n", i);
      string str = repeat_str(i, testString);
      string result = run_simulation(a, str, substr, 10);
      resultsFile << result + "\n";
    }
    resultsFile.close();

    printf("\n Search over!");
}

string repeat_str(int N, string str) {
  string new_str = str;
  for (int i = 0; i < N; i++) {
    new_str += str;
  }
  return new_str;
}

string run_simulation(vector<int>& a, string str, string substr, int N) {
  double t1, t2, t;
  vector<double> results_seq;
  vector<double> results_par;

  // SEQUENTIAL
  for (int i = 0; i < N; i++) {
    t1 = omp_get_wtime();
    int countSeq = kmp_findsubstr(a, str, substr, false);
    t2 = omp_get_wtime();
    t = t2-t1;
    results_seq.push_back(t);
    printf("Matches found in sequantial: %d\n", countSeq);
  }

  // PARALLEL
  for (int i = 0; i < N; i++) {
    t1 = omp_get_wtime();
    int countPar = kmp_findsubstr_par(a, str, substr, false);
    t2 = omp_get_wtime();
    t = t2-t1;
    results_par.push_back(t);
    printf("Matches found in sequantial: %d\n", countPar);
  }

  double sum_seq = std::accumulate(results_seq.begin(), results_seq.end(), 0.0);
  double mean_seq = sum_seq / N;

  double sum_par = std::accumulate(results_par.begin(), results_par.end(), 0.0);
  double mean_par = sum_par / N;

  string result = to_string(str.length()) + " " + to_string(substr.length()) + " " + to_string(mean_seq) + " " + to_string(mean_par);
  return result;
}

void printarray(vector<int>& a, int n) {
  printf("[");
  for (int i = 0; i < n; i++) {
    printf("%d ", a[i]);
  }
  printf("]\n");
}

/*
Generate the prefix/suffix array of the substring
For example with the substring of 
"aabdaaby"
we would have the following array:
[0,1,0,0,1,2,3,0,0]
*/
void gensubstrarr(vector<int>& a, string substr) {
  int j = 0;
  for (int i = 1; i < substr.length(); i++) {
      if (substr[i] == substr[j]) {
        j++;
      }
      else {
        j = 0;
      }
      a.push_back(j);
  } 
}

/*
KMP string match search, utilizing the substr arr generated by the method above
*/
int kmp_findsubstr(vector<int>& a, string str, string substr, bool withPrint) {
  int j = 0;
  int count = 0;
  // int startI = 0;
  // printf("Start serach\n");
  for (int i = 0; i < str.length(); i++) {
    // printf("Running in char: %d\n", i);
    // if (withPrint) printf("Comparing i: %d/%c from string to substr %d/%c\n", i, str[i], j, substr[j]);
    if (str[i] == substr[j]) {
      // Set start index of substring if isn't already set
      // if (startI < 0) startI = i;
      // if j == substr.length() - 1 the complete substring is found and we can return the result successfully
      if (substr.length() - 1 == j) {
        // if (withPrint) printf("String found! Ending\n\n");
        count++;
        // return startI;
      }
      j++;
    } else {
      // if (withPrint) printf("\nStarting prefix check from i: %d and j: %d\n", i, j);
      // From suffix array find if we have a prefix to continue the search from
      while (j != 0) {
        // if (withPrint) printf("j: %d, value at a[j]: %d, change j to this\n", j, a[j]);
        j = a[j - 1]; // New j is the end of the already found prefix, taken from the suffix array
        // startI = i - j; // New start index is the length of prefix (j) to the left => i - j
        // if (withPrint) printf("Comparing i: %d/%c from string to substr %d/%c\n", i, str[i], j, substr[j]);
        if (str[i] == substr[j]) {
          // if (withPrint) printf("Suffix match found\n");
          break;
        }
      }
      // if (withPrint) printf("Prefix check over\n\n");
    }
  }
  return count;
}

/*
KMP string match search parallellisized
*/
int kmp_findsubstr_par(vector<int>& a, string str, string substr, bool withPrint) {
  int result = -1;
  int totalCount = 0;
  #pragma omp parallel
  {
    int threadCount = omp_get_num_threads();
    int substrParts = (int)floor(str.length() / substr.length());
    // If str.length/substr.length is smaller than thread count, take the result of division as the amount of parts
    // Otherwise we divide the search to the amonut of threads
    int partsCount = (threadCount > substrParts) ? substrParts : threadCount;
    // printf("Parts of the substring length in og string: %d\n", substrParts);
    // printf("Thread count: %d\n", threadCount);
    // printf("Work parts: %d\n", partsCount);
    int tid = omp_get_thread_num();
    int partLength = (int)ceil(str.length() / (double)partsCount);
    // Recalculate count of parts, because it is possible to have been reduced by one change with specific length of string/num of threads calculations
    partsCount = (int)ceil(str.length() / (double)partLength);
    int startIndex = tid * partLength;
    // Dont run with thread if it's startIndex is already outside of string (can occur for couple of reasons)
    if (startIndex < str.length()) {
      // if (startIndex + partLength > str.length()) {
      //   partLength = str.length() - startIndex - 1; // To reach exaclty last letter to avoid out_of_range error
      // }
      string searchPart = str.substr(startIndex, partLength);
      // if (withPrint) printf("Thread %d: my string starts from: %d and is: %s\n", tid, startIndex, searchPart.c_str());
      // int matchIndex = kmp_findsubstr(a, searchPart, substr, false);
      int count = kmp_findsubstr(a, searchPart, substr, false);
      totalCount += count;
      // if (withPrint) printf("Thread %d result: %d\n", tid, count);
      // if (matchIndex >= 0) result = matchIndex + startIndex;

      // Check the connecting parts, meaning the parts between the parts
      // This means check from n-1 (n = length of substring) characters to the left from the separation to n-1 to the right
      // Exclude thread number 0 because it's startIndex doesnt point to any gap
      if (tid != 0) {
        int newStartIndex = startIndex - substr.length() + 1;
        int endIndex = startIndex + substr.length() - 1;
        string newSearchPart = str.substr(newStartIndex, endIndex - newStartIndex);
        // if (withPrint) printf("Part 2: Thread %d: my string starts from: %d and is: %s\n", tid, newStartIndex, newSearchPart.c_str());
        // int matchIndex = kmp_findsubstr(a, newSearchPart, substr, false);
        int count = kmp_findsubstr(a, newSearchPart, substr, false);
        totalCount += count;
        // if (withPrint) printf("Part 2: Thread %d result: %d\n", tid, count);
        // if (matchIndex >= 0) result = matchIndex + newStartIndex;
      }
    }
  }

  return totalCount;
}

